# 这是一个Vue前端埋点工具库
# 使用方法
```
npm install --save happy-track
//在main.js里
import {track} from 'happy-track' // 有一个use方法和一个指令方法
// 使用我们自己封装的第三方函数库
// 开始偷取
function addEvent (element, event, listener) {
  if (element.addEventListener) {
    element.addEventListener(event, listener, false)
  } else if (element.attachEvent) {
    element.attachEvent('on' + event, listener)
  } else {
    element['on' + event] = listener
  }
}
Vue.prototype.$track = track
Vue.directive('track', {
  bind (el, binding) {
    addEvent(el, 'click', () => {
      track('directive', binding)
    })
  },
  unbind: function (el) {
    addEvent(el, 'click', function () {})
  }
})
```


[Toc]
# 前言
>在很多项目中，埋点数据使用表格来统计的，随着项目的进行，数据量越来越复杂，越来越难以维护。需要开发一整套系统，从埋点的录入到代码的输出。
# 为什么需要前端监控
>获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向.
前端监控可以分为三类：数据监控、性能监控和异常监控
1. 数据监控
    * 数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：
      1. 流量：PV/UV、单页面访问数据、商品浏览数据等；
      2. 商品：商品曝光数据、浏览数据等；
      3. 交易：访客数据、下单数据等；
      4. 客户：访客数据、粉丝数据等；
      5. 其他：推广活动数据等。 
    * PV/UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数
    * 用户在每一个页面的停留时间
    * 用户通过什么入口来访问该网页
    * 用户在相应的页面中触发的行为

==统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。==
2. 性能监控
* 性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：
    * 不同用户，不同机型和不同系统下的首屏加载时间
    * 白屏时间
    * http等请求的响应时间
    * 静态资源整体下载时间
    * 页面渲染时间
    * 页面交互动画完成时间

==这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。==
3. ~~异常监控~~(这个需求偏开发侧，目前采用一个第三方付费的平台fundebug)
> 此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：
* Javascript的异常监控
* 样式丢失的异常监控
# 埋点架构设计
![image](https://raw.githubusercontent.com/lbb2446/diagram/master/Untitled%20Diagram.png?i=1)

# 常用前端埋点方案总结
 > 实现前端监控的步骤为：前端埋点和上报、数据处理和数据分析。首要的步骤就是前端埋点和上报，也就是数据的收集阶段。数据收集的丰富性和准确性会影响对产品线上效果的判别结果。
 目前常见的前端埋点方法分为三种：代码埋点、可视化埋点和无痕埋点。下面一一介绍每一种埋点的方法。
1. 代码埋点
代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等。
    * 代码埋点的优点：
    可以在任意时刻，精确的发送或保存所需要的数据信息。
    * 缺点：
    工作量较大，每一个组件的埋点都需要添加相应的代码
2. 可视化埋点
通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。
可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。
    * 缺点：
    可视化埋点可以埋点的控件有限，不能手动定制。
3. 无埋点
无埋点并不是说不需要埋点，而是全部埋点，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析因此实现“无埋点”统计。
从语言层面实现无埋点也很简单，比如从页面的js代码中，找出dom上被绑定的事件，然后进行全埋点。
    * 无埋点的优点：
    由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象
    * 缺点：
    无埋点采集全量数据，给数据传输和服务器增加压力
    无法灵活的定制各个事件所需要上传的数据

==综上所诉，我们最终采用无埋点+拓展代码埋点的形式来设计前端的埋点插件==
# 前端埋点方案设计
 1. 监控数据
首先我们需要明确一个产品或者网页，普遍需要监控和上报的数据。监控的分为三个阶段：用户进入网页首页、用户在网页内部交互和交互中报错。：
2. 埋点方案
在实际项目中考虑到上报数据的灵活定制，以及减少数据传输和服务器的压力，在所需埋点处不多的情况下，常用的方式是代码埋点。
以用户进入首页为例，我们在首页渲染完成后会发送事件类型和类型相关的数据给server端，告知首页的监控信息。
3. 上报周期和上报数据类型
如果埋点的事件不是很多，上报可以时时进行，比如监控用户的交互事件，可以在用户触发事件后，立刻上报用户所触发的事件类型。如果埋点的事件较多，或者说网页内部交互频繁，可以通过本地存储的方式先缓存上报信息，然后定期上报。
4. 接着来确定需要埋点上报的数据，上报的信息包括用户个人信息以及用户行为，主要数据可以分为：
    * who: appid(系统或者应用的id),userAgent(用户的系统、网络等信息)
    * when: timestamp(上报的时间戳)
    * from where: currentUrl(用户当前url)，fromUrl(从哪一个页面跳转到当前页面)，type(上报的事件类型),element(触发上报事件的元素）
    * what: 上报的自定义扩展数据data:{},扩展数据中可以按需求定制，比如包含uid等信息 
# 数据结构
 * 参考xmind
# 前端上报方案设计
  1.基本流程
   > ![image](https://images2015.cnblogs.com/blog/606248/201603/606248-20160305160111752-2031507489.png)

   >  当用户从浏览器打开（点击）一个页面时，浏览器首先会发出一个http的请求，服务器端返回HTML内容，其中夹杂着一段js代码。这个代码片段一般会动态创建一个script标签，并将src指向一个单独的js文件，此时这个单独的js文件（图1中绿色节点）会被浏览器请求到并执行，这个js往往就是真正的数据收集脚本。数据收集完成后，js会请求一个后端的数据收集脚本（图1中的backend）。，js会将收集到的数据通过http参数的方式传递给后端脚本，后端脚本解析参数并按固定格式记录到访问日志，同时可能会在http响应中给客户端种植一些用于追踪的cookie。
>   2. 埋设js代码 （这里有一个问题，因为npm需要把代码放在github，或者搭建企业私有的npm，但是目前来说没有必要，那放在github是否有安全性或者其他方面的问题）
   ```
   npm install lstrack
   //在代码内填充
   import {track} from 'lstrack'
   
   //组件内
   track(type,dosomething)
   
   ```
 
 
  3.异步收集数据
1. 通过浏览器内置javascript对象收集信息，如页面title（通过document.title）、referrer（上一跳url，通过document.referrer）、用户显示器分辨率（通过windows.screen）、cookie信息（通过document.cookie）等等一些信息。
2. 解析收集配置信息。这里面可能会包括用户自定义的事件跟踪、业务数据（如电子商务网站的商品编号等）等。
3. 将上面两步收集的数据按预定义格式解析并拼接。
4. 请求一个后端脚本，将信息放在http request参数中携带给后端脚本。
    
==这里唯一的问题是步骤4，javascript请求后端脚本常用的方法是ajax，但是ajax是不能跨域请求的。这里在被统计网站的域内执行，而后端脚本在另外的域，ajax行不通。一种通用的方法是js脚本创建一个Image对象，将Image对象的src属性指向后端脚本并携带参数，此时即实现了跨域请求后端。这也是后端脚本为什么通常伪装成gif文件的原因。==
 
  4. 后端脚本执行阶段
        1. 解析http请求参数的到信息。
        2. 从服务器（WebServer）中获取一些客户端无法获取的信息，如访客ip等。
        3. 将信息按格式/类型写入log。
        4. 生成一副1×1的空gif图片作为响应内容并将响应头的Content-type设为image/gif。
# 后端埋点接收方案设计
 * 请求方式：由于埋点系统为通用系统，不耦合到各个业务系统中，所以需要跨域访
问，拟采用 jsonp 方式跨域访问/伪造图片请求。
 * 数据流向：埋点系统为通用系统，可能多用户并发，访问量会很大，因此需要高并发
写入支持，引入 mq 解耦延迟处理，数据流向：前端->埋点系统->mq->mongo
 * 数据处理流程
    1. 消息队列消息产生
    系统接收到前端数据，对数据进行 base64 解码，将数据解析成 java 对象，部分公共数
    据填充，如后端接收时间、token 填充等，将数据发送到 MQ，响应 http
    2. 埋点系统从消息队列消费数据
    埋点系统监听 mq 的某队列，有可消费消息时，消费消息，解析消息，做数据最后填充，
    并写入数据库
    3. ip 解析方案
    采用高德地图和百度地图双 ip 解析方案，因为百度地图能解析出运营商信息，故百度地
    图 api 优先使用，如若百度地图未能解析出 ip 的位置，再采用高德地图解析一次
    4. 异常处理
    假如埋点数据从前端到后端之后，解析过程中出现异常，则将异常数据记录在案，以方便
    查找和定位问题
# 埋点管理平台功能
 * 可创建埋点测试用例，打通埋点管理平台，支持多条件筛选埋点
 * 支持发起埋点测试实例，只展示埋点测试用例中的埋点，多余信息单独展示
 *  ~~自动化提示埋点打错、打漏和打重，前端界面高亮展示，生成测试报告~~
# 前端监控结果可视化展示系统的设计
- 当后端得到前端上报的信息之后，经过数据分析和处理，需要前端可视化的展示数据分析后的结果。
- 流量数据：
    1. PV/UV；
    2. 单页面访问数据； 
    3. 单页面分享数据；
    4. 商品浏览数据等。
- 商品数据
    1. 商品曝光数据；
    2. 浏览数据；
    3. 转化数据等。
- 交易数据
    1. 访客数据
    2. 下单数据
    3. 支付数据等。
- 客户数据
    1. 访客数据
    2. 粉丝数据
    3. 留存数据等。
- 其他特定数据
    1. 推广活动数据；
    2. 卡券使用数据等。
- 对于单个用户来说需要展示的监控信息为：
    1. 单个用户，在交互过程中触发各个埋点事件的次数
    2. 单个用户，在某个时间周期内，访问本网页的入口来源
    3. 单个用户，在每一个子页面的停留时间
- 对于全体用户需要展示的信息为：
    1. 某一个时间段内网页的PV和UV
    2. 全体用户访问网页的设备和操作系统分析
    3. 某一个时间段内访问本网页的入口来源分析
    4. 全体用户在访问本网页时，在交互过程中触发各个埋点事件的总次数
    5. 全体用户在访问本网页时，网页上报异常的集合
- 筛选功能集合：
    1. 时间筛选：提供今日（00点到当前时间）、本周、本月和全年
    2. 用户筛选：提供根据用户id删选出用户行为的统计信息
    3. 设备筛选：筛选不同系统的整体展示信息